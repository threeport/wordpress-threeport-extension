// generated by 'threeport-sdk gen' - do not edit

package v0

import (
	"context"
	"fmt"
	tp_api "github.com/threeport/threeport/pkg/api/v0"
	tp_client "github.com/threeport/threeport/pkg/client/v0"
	kube "github.com/threeport/threeport/pkg/kube/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	api_v0 "github.com/threeport/wordpress-threeport-extension/pkg/api/v0"
	errors "k8s.io/apimachinery/pkg/api/errors"
	meta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	dynamic "k8s.io/client-go/dynamic"
	"net/http"
)

const (
	DbInitFilename            = "db.sql"
	DbInitLocation            = "/etc/threeport/db-create"
	defaultNamespace          = "threeport-wordpress"
	defaultThreeportNamespace = "threeport-control-plane"
	apiServerDeployName       = "threeport-wordpress-api-server"
	extensionName             = "lander2k2.com/wordpress-extension-api"
)

// Installer contains the values needed for an extension installation.
type Installer struct {
	// dynamice interface client for Kubernetes API
	KubeClient dynamic.Interface

	// Kubernetes API REST mapper
	KubeRestMapper *meta.RESTMapper

	// The Kubernetes namespace to install the extension components in.
	ExtensionNamespace string

	// The Kubernetes namespace the Threeport control plane is installed in.
	ThreeportNamespace string
}

// NewInstaller returns a wordpress extension installer with default values.
func NewInstaller(
	kubeClient dynamic.Interface,
	restMapper *meta.RESTMapper,
) *Installer {
	defaultInstaller := Installer{
		ExtensionNamespace: defaultNamespace,
		KubeClient:         kubeClient,
		KubeRestMapper:     restMapper,
		ThreeportNamespace: defaultThreeportNamespace,
	}

	return &defaultInstaller
}

// InstallWordpressExtension installs the controller and API for the wordpress extension.
func (i *Installer) InstallWordpressExtension() error {
	// create namespace
	var namespace = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "v1",
			"kind":       "Namespace",
			"metadata": map[string]interface{}{
				"name": i.ExtensionNamespace,
			},
		},
	}

	if _, err := kube.CreateOrUpdateResource(
		namespace,
		i.KubeClient,
		*i.KubeRestMapper,
	); err != nil {
		return fmt.Errorf("failed to create/update wordpress extension namespace: %w", err)
	}

	// copy secrets into extension namespace
	if err := copySecret(
		i.KubeClient,
		*i.KubeRestMapper,
		"db-root-cert",
		i.ThreeportNamespace,
		i.ExtensionNamespace,
	); err != nil {
		return fmt.Errorf("failed to copy secret: %w", err)
	}

	if err := copySecret(
		i.KubeClient,
		*i.KubeRestMapper,
		"db-threeport-cert",
		i.ThreeportNamespace,
		i.ExtensionNamespace,
	); err != nil {
		return fmt.Errorf("failed to copy secret: %w", err)
	}

	if err := copySecret(
		i.KubeClient,
		*i.KubeRestMapper,
		"encryption-key",
		i.ThreeportNamespace,
		i.ExtensionNamespace,
	); err != nil {
		return fmt.Errorf("failed to copy secret: %w", err)
	}

	if err := copySecret(
		i.KubeClient,
		*i.KubeRestMapper,
		"controller-config",
		i.ThreeportNamespace,
		i.ExtensionNamespace,
	); err != nil {
		return fmt.Errorf("failed to copy secret: %w", err)
	}

	if err := copySecret(
		i.KubeClient,
		*i.KubeRestMapper,
		"db-config",
		i.ThreeportNamespace,
		i.ExtensionNamespace,
	); err != nil {
		return fmt.Errorf("failed to copy secret: %w", err)
	}

	// create configmap used to initialize API database
	var dbCreateConfig = &unstructured.Unstructured{Object: map[string]interface{}{
		"apiVersion": "v1",
		"data": map[string]interface{}{
			"db.sql": "CREATE USER IF NOT EXISTS threeport;\nCREATE DATABASE IF NOT EXISTS threeport_wordpress_api encoding='utf-8';\nGRANT ALL ON DATABASE threeport_wordpress_api TO threeport;",
		},
		"kind": "ConfigMap",
		"metadata": map[string]interface{}{
			"name":      "db-create",
			"namespace": i.ExtensionNamespace,
		},
	}}

	if _, err := kube.CreateOrUpdateResource(dbCreateConfig, i.KubeClient, *i.KubeRestMapper); err != nil {
		return fmt.Errorf("failed to create/update wordpress DB initialization configmap: %w", err)
	}

	// install wordpress API server deployment
	var wordpressApiDeploy = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "apps/v1",
			"kind":       "Deployment",
			"metadata": map[string]interface{}{
				"name":      apiServerDeployName,
				"namespace": i.ExtensionNamespace,
			},
			"spec": map[string]interface{}{
				"replicas": 1,
				"selector": map[string]interface{}{
					"matchLabels": map[string]interface{}{
						"app.kubernetes.io/name": apiServerDeployName,
					},
				},
				"strategy": map[string]interface{}{
					"rollingUpdate": map[string]interface{}{
						"maxSurge":       "25%",
						"maxUnavailable": "25%",
					},
					"type": "RollingUpdate",
				},
				"template": map[string]interface{}{
					"metadata": map[string]interface{}{
						"creationTimestamp": nil,
						"labels": map[string]interface{}{
							"app.kubernetes.io/name": apiServerDeployName,
						},
					},
					"spec": map[string]interface{}{
						"containers": []interface{}{
							map[string]interface{}{
								"args": []interface{}{
									"-auto-migrate=true",
									"-auth-enabled=false",
								},
								"command": []interface{}{
									"/rest-api",
								},
								"envFrom": []interface{}{
									map[string]interface{}{
										"secretRef": map[string]interface{}{
											"name": "encryption-key",
										},
									},
								},
								"image":           "localhost:5001/threeport-wordpress-rest-api:dev",
								"imagePullPolicy": "IfNotPresent",
								"name":            "api-server",
								"ports": []interface{}{
									map[string]interface{}{
										"containerPort": 1323,
										"name":          "api",
										"protocol":      "TCP",
									},
								},
								"readinessProbe": map[string]interface{}{
									"failureThreshold": 1,
									"httpGet": map[string]interface{}{
										"path":   "/readyz",
										"port":   8081,
										"scheme": "HTTP",
									},
									"initialDelaySeconds": 1,
									"periodSeconds":       2,
									"successThreshold":    1,
									"timeoutSeconds":      1,
								},
								"volumeMounts": []interface{}{
									map[string]interface{}{
										"mountPath": "/etc/threeport/",
										"name":      "db-config",
									},
									map[string]interface{}{
										"mountPath": "/etc/threeport/db-certs",
										"name":      "db-threeport-cert",
									},
								},
							},
						},
						"initContainers": []interface{}{
							map[string]interface{}{
								"command": []interface{}{
									"bash",
									"-c",
									fmt.Sprintf("cockroach sql --certs-dir=/etc/threeport/db-certs --host crdb.%s.svc.cluster.local --port 26257 -f /etc/threeport/db-create/db.sql", i.ThreeportNamespace),
								},
								"image":           "cockroachdb/cockroach:v23.1.14",
								"imagePullPolicy": "IfNotPresent",
								"name":            "db-init",
								"volumeMounts": []interface{}{
									map[string]interface{}{
										"mountPath": "/etc/threeport/db-create",
										"name":      "db-create",
									},
									map[string]interface{}{
										"mountPath": "/etc/threeport/db-certs",
										"name":      "db-root-cert",
									},
								},
							},
							map[string]interface{}{
								"args": []interface{}{
									"-env-file=/etc/threeport/env",
									"up",
								},
								"command": []interface{}{
									"/database-migrator",
								},
								"image":           "localhost:5001/threeport-wordpress-database-migrator:dev",
								"imagePullPolicy": "IfNotPresent",
								"name":            "database-migrator",
								"volumeMounts": []interface{}{
									map[string]interface{}{
										"mountPath": "/etc/threeport/",
										"name":      "db-config",
									},
									map[string]interface{}{
										"mountPath": "/etc/threeport/db-certs",
										"name":      "db-threeport-cert",
									},
								},
							},
						},
						"restartPolicy":                 "Always",
						"terminationGracePeriodSeconds": 30,
						"volumes": []interface{}{
							map[string]interface{}{
								"name": "db-root-cert",
								"secret": map[string]interface{}{
									"defaultMode": 420,
									"secretName":  "db-root-cert",
								},
							},
							map[string]interface{}{
								"name": "db-threeport-cert",
								"secret": map[string]interface{}{
									"defaultMode": 420,
									"secretName":  "db-threeport-cert",
								},
							},
							map[string]interface{}{
								"name": "db-config",
								"secret": map[string]interface{}{
									"defaultMode": 420,
									"secretName":  "db-config",
								},
							},
							map[string]interface{}{
								"configMap": map[string]interface{}{
									"defaultMode": 420,
									"name":        "db-create",
								},
								"name": "db-create",
							},
						},
					},
				},
			},
		},
	}

	if _, err := kube.CreateOrUpdateResource(wordpressApiDeploy, i.KubeClient, *i.KubeRestMapper); err != nil {
		return fmt.Errorf("failed to create/update wordpress API deployment: %w", err)
	}

	// install wordpress API server service
	var wordpressApiService = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "v1",
			"kind":       "Service",
			"metadata": map[string]interface{}{
				"labels": map[string]interface{}{
					"app.kubernetes.io/name": apiServerDeployName,
				},
				"name":      apiServerDeployName,
				"namespace": i.ExtensionNamespace,
			},
			"spec": map[string]interface{}{
				"ports": []interface{}{
					map[string]interface{}{
						"name":       "http",
						"port":       80,
						"protocol":   "TCP",
						"targetPort": 1323,
					},
				},
				"selector": map[string]interface{}{
					"app.kubernetes.io/name": apiServerDeployName,
				},
			},
		},
	}
	if _, err := kube.CreateOrUpdateResource(wordpressApiService, i.KubeClient, *i.KubeRestMapper); err != nil {
		return fmt.Errorf("failed to create/updated wordpress API service: %w", err)
	}

	// install wordpress controller
	var wordpressControllerDeploy = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "apps/v1",
			"kind":       "Deployment",
			"metadata": map[string]interface{}{
				"name":      "threeport-wordpress-controller",
				"namespace": i.ExtensionNamespace,
			},
			"spec": map[string]interface{}{
				"replicas": 1,
				"selector": map[string]interface{}{
					"matchLabels": map[string]interface{}{
						"app.kubernetes.io/name": "threeport-wordpress-controller",
					},
				},
				"strategy": map[string]interface{}{
					"rollingUpdate": map[string]interface{}{
						"maxSurge":       "25%",
						"maxUnavailable": "25%",
					},
					"type": "RollingUpdate",
				},
				"template": map[string]interface{}{
					"metadata": map[string]interface{}{
						"labels": map[string]interface{}{
							"app.kubernetes.io/name": "threeport-wordpress-controller",
						},
					},
					"spec": map[string]interface{}{
						"containers": []interface{}{
							map[string]interface{}{
								"args": []interface{}{
									"-auth-enabled=false",
								},
								"command": []interface{}{
									"/wordpress-controller",
								},
								"envFrom": []interface{}{
									map[string]interface{}{
										"secretRef": map[string]interface{}{
											"name": "controller-config",
										},
									},
									map[string]interface{}{
										"secretRef": map[string]interface{}{
											"name": "encryption-key",
										},
									},
								},
								"image":           "localhost:5001/threeport-wordpress-controller:dev",
								"imagePullPolicy": "IfNotPresent",
								"name":            "wordpress-controller",
								"readinessProbe": map[string]interface{}{
									"failureThreshold": 1,
									"httpGet": map[string]interface{}{
										"path":   "/readyz",
										"port":   8081,
										"scheme": "HTTP",
									},
									"initialDelaySeconds": 1,
									"periodSeconds":       2,
									"successThreshold":    1,
									"timeoutSeconds":      1,
								},
							},
						},
						"restartPolicy":                 "Always",
						"terminationGracePeriodSeconds": 30,
					},
				},
			},
		},
	}

	if _, err := kube.CreateOrUpdateResource(wordpressControllerDeploy, i.KubeClient, *i.KubeRestMapper); err != nil {
		return fmt.Errorf("failed to create/update wordpress controller deployment: %w", err)
	}

	return nil
}

// copySecret copies a secret from one namespace to another.  The function
// returns without error if the secret already exists in the target namespace.
func copySecret(
	dynamicClient dynamic.Interface,
	restMapper meta.RESTMapper,
	secretName string,
	sourceNamespace string,
	targetNamespace string,
) error {
	secretGVR := schema.GroupVersionResource{
		Group:    "",
		Resource: "secrets",
		Version:  "v1",
	}
	secretGK := schema.GroupKind{
		Group: "",
		Kind:  "Secret",
	}

	mapping, err := restMapper.RESTMapping(secretGK, secretGVR.Version)
	if err != nil {
		return fmt.Errorf("failed to get RESTMapping for Secret resource: %w", err)
	}

	targetSecretResource := dynamicClient.Resource(mapping.Resource).Namespace(targetNamespace)
	_, err = targetSecretResource.Get(context.TODO(), secretName, metav1.GetOptions{})
	if err == nil {
		// secret already exists, return nil
		return nil
	} else if !errors.IsNotFound(err) {
		return fmt.Errorf(
			"failed to check if Secret '%s' exists in namespace '%s': %w",
			secretName,
			targetNamespace,
			err,
		)
	}

	secretResource := dynamicClient.Resource(mapping.Resource).Namespace(sourceNamespace)
	secret, err := secretResource.Get(context.TODO(), secretName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf(
			"failed to get Secret '%s' from namespace '%s': %w",
			secretName,
			sourceNamespace,
			err,
		)
	}

	secret.SetNamespace(targetNamespace)
	secret.SetResourceVersion("")
	secret.SetUID("")
	secret.SetSelfLink("")
	secret.SetCreationTimestamp(metav1.Time{})
	secret.SetManagedFields(nil)

	_, err = targetSecretResource.Create(context.TODO(), secret, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create/update Secret in namespace '%s': %w", targetNamespace, err)
	}

	return nil
}

// RegisterWordpressExtension calls the Threeport API to register the extension
// API so that extension object requests are proxied to the Wordpress extension
// API.
func (i *Installer) RegisterWordpressExtension(
	apiClient *http.Client,
	apiAddr string,
) error {
	// check to see if extension is already registered
	var existingExtApi *tp_api.ExtensionApi
	existingExtApi, _ = tp_client.GetExtensionApiByName(apiClient, apiAddr, extensionName)
	if existingExtApi.ID == nil {
		// register the extension in the Threeport API
		extensionApi := tp_api.ExtensionApi{
			Endpoint: util.Ptr(fmt.Sprintf("%s.%s.svc.cluster.local", apiServerDeployName, defaultNamespace)),
			Name:     util.Ptr(extensionName),
		}
		createdExtApi, err := tp_client.CreateExtensionApi(apiClient, apiAddr, &extensionApi)
		if err != nil {
			return fmt.Errorf("failed to create extension API object in Threeport API: %w", err)
		}
		existingExtApi = createdExtApi
	}

	// add all the paths to the registered extension if they don't already exist
	allRoutePaths := []string{
		api_v0.PathWordpressDefinitionVersions,
		api_v0.PathWordpressDefinitions,
		api_v0.PathWordpressInstanceVersions,
		api_v0.PathWordpressInstances,
	}
	for _, path := range allRoutePaths {
		// check to see if route path exists
		query := fmt.Sprintf("path=%s&extensionapiid=%d", path, *existingExtApi.ID)
		existingRoutes, err := tp_client.GetExtensionApiRoutesByQueryString(apiClient, apiAddr, query)
		if err != nil {
			return fmt.Errorf("failed to check for existing route path %s", path, err)
		}
		if len(*existingRoutes) == 0 {
			// route path doesn't exist - create it
			route := tp_api.ExtensionApiRoute{
				ExtensionApiID: existingExtApi.ID,
				Path:           &path,
			}
			_, err := tp_client.CreateExtensionApiRoute(apiClient, apiAddr, &route)
			if err != nil {
				return fmt.Errorf("failed to create route with path %s in Threeport API: %w", path, err)
			}
		}
	}

	return nil
}
